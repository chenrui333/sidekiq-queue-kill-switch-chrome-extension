# CI workflow for Sidekiq Queue Kill Switch Chrome Extension
#
# Runs on PRs and pushes to main. Validates the extension structure,
# runs sanity checks, and verifies the package builds successfully.

name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

# Read-only permissions for CI
permissions:
  contents: read

jobs:
  build:
    name: Build and Validate
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@3d267786b128fe76c2f16a390aa2448b815359f3 # v2
        with:
          bun-version: latest

      - name: Validate manifest.json structure
        run: |
          echo "Checking manifest.json..."

          # Use python3 to parse and validate JSON (more portable than jq)
          python3 << 'EOF'
          import json
          import sys

          with open('manifest.json', 'r') as f:
              manifest = json.load(f)

          errors = []

          # Check manifest_version is 3
          if manifest.get('manifest_version') != 3:
              errors.append(f"manifest_version must be 3, got: {manifest.get('manifest_version')}")

          # Check content_scripts exists and has correct match pattern
          content_scripts = manifest.get('content_scripts', [])
          if not content_scripts:
              errors.append("content_scripts array is missing or empty")
          else:
              matches = content_scripts[0].get('matches', [])
              expected_pattern = "*://*/sidekiq/queues*"
              if expected_pattern not in matches:
                  errors.append(f"content_scripts matches must include '{expected_pattern}', got: {matches}")

          # Check version field exists and is valid
          version = manifest.get('version')
          if not version:
              errors.append("version field is missing")
          elif not all(part.isdigit() for part in version.split('.')):
              errors.append(f"version must be semver format (e.g., 1.0.0), got: {version}")

          # Check required fields
          for field in ['name', 'description']:
              if not manifest.get(field):
                  errors.append(f"Required field '{field}' is missing or empty")

          if errors:
              print("::error::Manifest validation failed:")
              for error in errors:
                  print(f"  - {error}")
              sys.exit(1)

          print(f"✓ manifest.json is valid (version: {version}, MV3)")
          EOF

      - name: Validate contentScript.js structure
        run: |
          echo "Checking src/contentScript.js..."

          python3 << 'EOF'
          import sys
          import re

          with open('src/contentScript.js', 'r') as f:
              content = f.read()

          errors = []

          # Check LOG_PREFIX constant exists with [SQKS] (handles const/let/var declarations)
          log_prefix_pattern = r"(const|let|var)\s+LOG_PREFIX\s*=\s*['\"]\[SQKS\]['\"]"
          if not re.search(log_prefix_pattern, content):
              errors.append("LOG_PREFIX constant not found (expected: const|let|var LOG_PREFIX = '[SQKS]';)")

          # Check key safety functions exist
          required_functions = [
              'findSubmitButton',
              'getAuthenticityToken',
              'submitQueueAction',
              'handleBulkAction',
              'injectControls'
          ]
          for func in required_functions:
              if f'function {func}' not in content:
                  errors.append(f"Required function '{func}' not found")

          # Check delete safety guard exists
          if 'delete' not in content.lower():
              errors.append("Delete safety guard check not found")

          if errors:
              print("::error::contentScript.js validation failed:")
              for error in errors:
                  print(f"  - {error}")
              sys.exit(1)

          print("✓ src/contentScript.js structure is valid")
          EOF

      - name: Validate CSS file exists
        run: |
          if [ ! -f "src/contentScript.css" ]; then
            echo "::error::src/contentScript.css not found"
            exit 1
          fi
          echo "✓ src/contentScript.css exists"

      - name: Validate icons exist
        run: |
          for size in 16 32 48 128; do
            if [ ! -f "icons/icon${size}.png" ]; then
              echo "::error::icons/icon${size}.png not found"
              exit 1
            fi
          done
          echo "✓ All required icons exist"

      - name: Build extension package
        run: make package

      - name: Verify built extension structure
        run: |
          echo "Verifying built extension..."

          # Check extension directory was created
          if [ ! -d "dist/extension" ]; then
            echo "::error::dist/extension directory not found"
            exit 1
          fi

          # Check generated manifest exists
          if [ ! -f "dist/extension/manifest.json" ]; then
            echo "::error::Generated manifest.json not found"
            exit 1
          fi

          # Verify generated manifest references assets/ paths
          python3 << 'EOF'
          import json
          import sys

          with open('dist/extension/manifest.json', 'r') as f:
              manifest = json.load(f)

          cs = manifest.get('content_scripts', [{}])[0]
          js_paths = cs.get('js', [])
          css_paths = cs.get('css', [])

          errors = []

          if not any('assets/contentScript.js' in p for p in js_paths):
              errors.append(f"Generated manifest should reference assets/contentScript.js, got: {js_paths}")

          if not any('assets/contentScript.css' in p for p in css_paths):
              errors.append(f"Generated manifest should reference assets/contentScript.css, got: {css_paths}")

          if errors:
              print("::error::Generated manifest validation failed:")
              for error in errors:
                  print(f"  - {error}")
              sys.exit(1)

          print("✓ Generated manifest.json references correct asset paths")
          EOF

          echo "✓ Built extension structure is valid"

      - name: Verify ZIP contents
        run: |
          echo "Verifying ZIP contents..."

          # Check ZIP was created
          if [ ! -f "dist/sidekiq-queue-kill-switch.zip" ]; then
            echo "::error::ZIP file not found"
            exit 1
          fi

          # List contents
          unzip -l dist/sidekiq-queue-kill-switch.zip

          # Verify required files are in ZIP (new paths after Vite build)
          python3 << 'EOF'
          import zipfile
          import sys

          required_files = [
              'manifest.json',
              'assets/contentScript.js',
              'assets/contentScript.css',
              'icons/icon16.png',
              'icons/icon32.png',
              'icons/icon48.png',
              'icons/icon128.png',
              'README.md',
              'LICENSE'
          ]

          with zipfile.ZipFile('dist/sidekiq-queue-kill-switch.zip', 'r') as z:
              zip_contents = z.namelist()

              missing = []
              for req in required_files:
                  if req not in zip_contents:
                      missing.append(req)

              if missing:
                  print("::error::ZIP is missing required files:")
                  for f in missing:
                      print(f"  - {f}")
                  sys.exit(1)

          print("✓ ZIP contains all required files")
          EOF

      - name: Upload build artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: sidekiq-queue-kill-switch-ci-${{ github.sha }}
          path: dist/sidekiq-queue-kill-switch.zip
          retention-days: 7
